拿过去## I/O

概述
> I/O 发生的场景为两种，一:文件的读写 二:网络通信.其中网络通信就是我们常说的Socket通信

### 相关概念

##### 1.进程缓冲区和操作系统（Lunix内核）缓冲区
**一次IO的读取操作分为两个阶段:**
    
    一.等待数据,等待数据从网络到达网卡.当等待到达之后,数据被复制到内核缓冲区.
    二.复制数据,讲内核缓冲区的数据复制到用户进程缓冲区.

> 用户进程的IO操作的read和write都是上层操作，不会直接和物理设备(磁盘)交互，在用户进程和物理设备之间，存在内核的缓冲区，对于物理设备数据的读取，首先会读取到内核的缓冲区，然后用户进程的read操作是从内核缓冲区读取数据到进程的缓冲区。那么对于用户进程的write操作，首先是复制用户进程缓冲区的数据到内核缓冲区，之后内核缓冲区的和物理设置交互。

> 缓冲区的作用是减少频繁地与设备之间的物理交换.

![系统调用read&write操作](\images\IO-缓冲区.png)



Java 服务器端，完成一次 socket 请求和响应，完整的流程如下：
- 客户端请求：Linux 通过网卡读取客户端的请求数据，将数据读取到内核缓冲区。
- 获取请求数据：Java 服务器通过 read 系统调用，从 Linux 内核缓冲区读取数据，再送入 Java
进程缓冲区。
- 服务器端业务处理：Java 服务器在自己的用户空间中处理客户端的请求。
- 服务器端返回数据：Java 服务器完成处理后，构建好的响应数据，将这些数据从用户缓冲
区写入内核缓冲区。这里用到的是 write 系统调用。
- 发送给客户端：Linux 内核通过网络 IO，将内核缓冲区中的数据写入网卡，网卡通过底层
的通信协议，会将数据发送给目标客户端。

##### 2.文件描述符(File Descriptor)

    文件描述符,又叫文件句柄.是指linux系统的进程在每打开一个文件(普通文件,目录文件,链接文件,设备文件)之后就会创建一个文件句柄(高效管理被打开的文件的索引,是一个非负整数,通常是小整数).每一个Socket创建一个文件句柄.<br>
    但是一个进程管理的文件句柄有限,默认1024个,超出之后报警.
    可以通过修改linux核心配置文件,增加数量.
    文件位置/etc/security/limits.conf
    soft nofile 100000
    hard nofile 100000
    
    ulimit -n 100000 可以临时修改,仅仅在当前用户空间,且是当前用回会话期间,一旦断开连接,就失效.


#### 一.Socket

###### 什么是Socket?

> Socket是进程间的通讯工具.关于本地进程间的通信可以网上百度,本地只讨论网络总的进程通信.本地进程可以依靠`PID`进程通信,而在网络中就要依靠 网络层的`IP地址`和传输层的`协议`+`端口PORT`.三元组(IP、协议、端口)可以标识网络间的进程。

> 使用TCP/IP协议的应用程序通常采用应用编程接口:UNIX BSD的套字节（Socket）和UNIX System V的TLI（已经被淘汰）。就目前而言，几乎所有的应用程序都是采用socket，而现在又是网络时代，网络中进程通信是无处不在，这就是为什么说“一切皆socket”。

> Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

###### TCP/IP 的三次握手 四次挥手

[参考:最通俗易懂的三次握手、四次挥手理解
](https://blog.csdn.net/weixin_45479946/article/details/108517653)

三次握手:

    1.客户端调用connect向服务端发送SYN J包,这是connect阻塞;
    2.服务端收到SYN J包,调用accept接受请求,并发送SYN k和ACK J+1,这时accept阻塞;
    3.客户端收到SYN k和ACK J+1后,对SYN K进行确认,发送ACK K+1确认,服务器收到ACk K+1,accept返回,握手成功

四次挥手:
    
    在网络数据传输中，传输层协议断开连接的过程我们称为四次挥手
    
    第一次，A端像B端发送FIN结束报文段，准备关闭连接
    
    第二次，B端确认A端的FIN，表示自己已经收到对方关闭连接的请求
    
    中间这段时间，A端停止向B端发送数据，但是B端可以向A端发送数据，要将自己未处理完任务处理完
    
    第三次，B端向A端发送FIN结束报文段，准备关闭连接
    
    第四次，A端确认B端的FIN，进入TIME_WAIT状态，此时A端进程已经退出，但是连接还在
    
    当B端收到A端的ACK之后，先断开连接
    
    当A端等待2 MSL之后，确认的B端接收到ACK后，再断开连接
    
    发起断开连接请求的一端最后要进入有一个TIME_WAIT状态
    
    发起连接请求的可以是客户端也可以是服务器端

 




    为什么断开连接要四次?
    
    不像建立连接的过程,服务器端在调用了accept()之后,剩下的都交给内核来处理,用户空间不用做什么,断开连接是,A端调用close()关闭文件描述符后,A端就停止发送数据了进行发送,B端收到后结束报文段之后,的得知A端要断开连接了,但是B端可能有自己还没有处理完的数据,不能立即断开连接,就要先给出回复,表示自己已经收到消息了,然后将自己的数据处理完之后,可以断开连接的时候,再调用close()发出断开连接请求,在收到A端的确认回复之后,断开连接,这样看来每一步都不能少,但是有时候若服务器端没有什么要处理的数据,就看可以直接调用close()捎带上响应报文,此时就是3次
    
    为什么先发起断开连接请求的一端最后要等待 2MSL？
    
    MSL为一段报文从一段到一段的最大时间，也称为报文的最大生存时间，我们假设在上面的四次挥手过程中最后A端在收到B端的FIN之后，就关闭连接，最后B端在收到A端的确认报文之后也断开连接，这种情况是我们预期的
    
    试想是否存在这样的情况，在A端已经关闭连接后，但是发给B端的ACK报文中途丢失，此时B端就会重发FIN结束报文段，但是A端已经关闭与这台服务器的连接，并且已经开始了一段新的连接，那么A端收到这个过期的FIN，误认为是关闭当前连接，给出错误处理。
    
    也就是说A端等待 2MSL就 可以保证在B端没有收到A 到ACK时，B端重发的FIN,A端来的及处理，然后重新确认等待2 MSL，保证了最后的ACK 报文 B端成功收到。

### 二.I/O模型

[参考 :Linux IO模型 select poll epoll](https://segmentfault.com/a/1190000003063859)

###### 缓存IO

    缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。在 Linux 的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的页缓存（ page cache ）中，也就是说，数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。
    
    缓存 I/O 的缺点：
    数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。

###### 五种IO模型

    对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：
    1. 等待数据准备 (Waiting for the data to be ready)
    2. 将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)
    
    正式因为这两个阶段，linux系统产生了下面五种网络模式的方案。
    - 阻塞 I/O（blocking IO）
    - 非阻塞 I/O（nonblocking IO）
    - I/O 多路复用（ IO multiplexing）
    - 信号驱动 I/O（ signal driven IO）已经不使用了
    - 异步 I/O（asynchronous IO）
    
**解释同步和异步:**
    
    同步IO,是指用户空间和内核空间的IO的发起方式.同步IO是指用户空间的线程是主动发起IO请求的一方,内核被动接受.异步IO则反过来,是指系统内核是主动发起IO请求的一方,用户空间的进程是被动接受的一方.
    
**阻塞和非阻塞**
    
    阻塞是指用户进程在内核完成IO操作之前一直等待,内核彻底完成IO操作之后,返回用户进程,执行用户操作.阻塞时用户进程的状态.

 **同步阻塞 IO**
    
    在linux中，默认情况下所有的socket都是blocking，一个典型的读操作流程大概是这样：准备数据阶段,需要等待一个完整的数据包,这个时候就是阻塞的,

**同步非阻塞IO**
    
    当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。
    
    所以，nonblocking IO的特点是用户进程需要不断的主动询问kernel数据好了没有,实时性较高.
**多路复用**

    IO multiplexing就是我们说的select，poll，epoll，有些地方也称这种IO方式为event driven IO。select/epoll的好处就在于单个process就可以同时处理多个网络连接的IO。它的基本原理就是select，poll，epoll这个function会不断的轮询所负责的所有socket，当某个socket有数据到达了，就通知用户进程。
    
    在IO multiplexing Model中，实际中，对于每一个socket，一般都设置成为non-blocking，但是，如上图所示，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。

**异步IO**

    用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

### 三.NIO

**简介**

    传统IO是面向流的IO,NIO是面向缓冲区