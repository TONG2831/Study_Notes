### 一、类加载和JVM内存区域

##### 1.类的加载，字节码文件class
`.java`文件需要编译生成`.class`文件才能运行.启动JVM后,需要加载`.class`文件进`JVM`.

**类的加载过程**
1. 加载 读取文件
2. 验证 对字节码文件验证其是否符合`JVM`规范
3. 准备 为class分配内存空间,并为类属性(静态变量)分配内存空间,并初始化值 例如 `static int a =0`
4. 解析 符号引用替换为直接引用
5. 初始化 执行相关的静态代码块
6. 使用
7. 卸载


##### 2.类加载器的类型
- Bootstrap ClassLoader (启动类加载器) 加载 jdk安装目录 `jre\lib` 下的核心类库,该类库会在JVM启动后全部加载
- Extension ClassLoader(扩展类加载器) 加载 jdk 安装目录 `jre\lib\ext`目录下的类库
- Application ClassLoader(应用程序加载器) 加载 classpath路径下的类
- 自定义类加载器 开发者自定义加载器,满足特殊需求

##### 3.双亲委派机制(Parents Delegation Mode)
> 双亲委派机制是指类在加载的过程中调用加载器的顺序.

> 上述四个加载器是有一定的亲子层级结构的.

层级结构
```
graph TD
A[启动类加载器]-->B[扩展类加载器]
B[扩展类加载器]-->C[应用程序加载器]
C[应用程序加载器] --> D[自定义加载器1]
C[应用程序加载器] --> E[自定义加载器2]

```
类的加载顺序
```
graph TD
A[启动类加载器]--加载不了向下委托-->B[扩展类加载器]
B[扩展类加载器]--加载不了向下委托-->C[应用程序加载器]
C[应用程序加载器] --加载不了向下委托--> D[自定义加载器1]
C[应用程序加载器] --加载不了向下委托--> E[自定义加载器2]


E[自定义加载器2 开始加载类] --请求加载--> C[应用程序加载器]
C[应用程序加载器] --请求加载--> B[扩展类加载器]
B[应用程序加载器] --请求加载--> A[启动类加载器]

```
##### 4.JVM的内存区域划分

方法区

> 方法区也是所有线程共享。主要用于存储类的信息(包括class对象的Method，Field等)、常量池、方法数据、方法代码等。方法区逻辑上属于堆的一部分，但是为了与堆进行区分，通常又叫“非堆”

方法区是JVM规范,`永久代`和`元数据空间`是JVM规范的实现.

永久代和元数据空间的区别

永久代: JDK1.7 只在HotSpot才有,使用JVM内存,永久代会为 GC 带来不必要的复杂度，并且回收效率偏低

元数据空间: JDK1.8以后,使用本地内存,元数据空间的大小只受本地内存的影响,防止内存溢出 OutofmemoryError: PermGen space;
metaspace没有了字符串常量池，而在jdk7的时候已经被移动到了堆中

程序计数器
> 记录执行的字节码指令的位置,每一个线程都有自己的单独的程序计数器

虚拟机栈
> 保存每个方法的局部变量等数据.每个线程都有自己的栈,线程为每个调用的方法创建栈帧.
> 栈帧里包含了方法的局部变量表,操作数栈,动态链接,出入口.在整个线程的执行周期内,方法不断入栈,出栈,直至执行结束.

堆内存

> 实例化的对象,会存放在堆内存中

内存区域图
![image](\images\JVM内存模型.png)

### 二、GC
问题:

我们常常讲的GC是针对堆内存的,那么就有个问题,在JVM内存区域的划分中,对于方法区和虚拟机栈是否会触发内存回收?

解答:

方法区又称为永久代,因为方法区存放的都是class字节码信息,以及类的静态变量,稳定性较强,一般不会回收,但是也可以回收,回收的条件为
- 堆内存中不存在该类的实例
- 堆内存中加载该类的加载器ClassLoader已经被回收
- 不存在对该类的字节码对象的引用.

虚拟机栈: 每个线程都有自己独立的虚拟机栈内存分配,一旦线程执行结束,占内存随即释放.


##### 年轻代和老年代
> jvm 根据对象的生命周期和使用情况,将堆内存划分为年轻代和老年代.<br/>
> 年轻代存储创建之后很快会回收的对象<br/>
> 老年代存储需要长期使用的对象

**jvm参数**
1.  -Xms:堆内存的最小值
2.  -Xmx:堆内存的最大值
3.  -Xmn:堆内存的新生代内存大小,扣除新生代内存就是老年代内存
4.  -XX:Permsize:永久代内存最小值 一般几百M就够了  jdk1.8 -XX:MetaspaceSize:
5.  -XX:MaxPermxSize:永久代内存最大值   jdk1.8 -XX:MaxMetasapceSize:
6.  -Xss:栈内存 一般 默认 521kb~1Mb


**如何估算自己的JVM内存**

1. 确定当前系统的核心功能的点,即压力点
2. 估算当前动能点请求量,每天的请求量按照 二八原则划分(80%的请求集中在20%的时间处理),估算峰值的每秒请求量
3. 计算每个请求的响应时间,计算每个请求的处理过程当中产生的对象,占用的堆内存大小
4. 每秒的请求数 * 每次请求的占用的内存大小= 每秒占用的内存大小,对结果扩大10~20倍甚至更多,因为在处理请求的同事也会产生其他的对象
5. 扩大后的结果即每秒的产生的堆内存,对比自己的JVM设置的堆内存大小,及可估算出多久新生代内存会满,多久老年代会满,从而计算出 minor gc的频次和full gc 的频次
6. minorGC 的合理时间 10ms以上一次MinorGC,每次时间不超过50ms

**什么情况下JVM内存中的一个对象会被回收?**
> 新生代满了会触发 Young GC，老年代满了会触发 Old GC。GC时会回收对象，那么具体是什么样的对象会被垃圾回收器回收呢？ 可达性分析算法，判断是否被 GC Roots 引用 判断引用类型：强引用、软引用、弱引用、虚引用 是否调用finialize()方法自救 首先，JVM 会通过可达性分析算法来判断哪些对象会被回收，哪些不会被回收。可达性分析算法会从一个对象触发，一层层向上，分析有谁在引用它，看是否有一个 GC Roots。 被 GC Roots 引用的对象就不会被垃圾回收。GC Roots 指的是局部变量，或者类的静态变量。具体可以看这篇文章：什么是被 GC Roots 直接引用的对象？。 其次，看引用类型。Java中有强引用、软引用、弱引用和虚引用： 强引用，被强引用的对象不会被回收 软引用，被软引用的对象一般并不会被回收，GC之后内存任然不够会被回收 弱引用，弱引用就像没有被引用，GC时直接回收 虚引用，很少用到需引用，可以忽略 所以总的来说： 有 GC Roots 的对象不能回收，没有 GC Roots 的对象可以回收 有 GC Roots 的对象，如果是软引用或者弱引用，也有可能被回收 最后，一个对象没有被 GC Roots 引用，是否立即就会被回收呢？ 也不一定立即被回收，该类可以重写finialize()方法，在finialize()中让一个 GC Roots 重新引用这个对象，就能自救。

**新生代垃圾回收算法**

标记清除算法:

在堆内存中通过可达性分析哪些对象是不能被回收的并标记,然后清除掉剩余的对象. 这种算法会造成内存碎片,空间浪费,因为标记清除之后,剩余对象在内存中式分散的,大一点的对象可能就分配不了.

复制算法:

把新生代内存分为两块,只使用其中一块内存,等待这块内存满了把存活的对象移动到另外一块内存中,不会产生内存碎片.但是只有一般的内存可以使用,内存空间浪费.

复制算法的优化:

![image](/images/新生代内存图.png)

如图所示,把新生代内存分为三份, 一个Eden取,两个survivor区,内存分配比例为80.  :10:10,每次只使用Eden和一个survivor区,当Eden区内存满了触发MinorGC,存活的对象移动到另一个空白的survivor区.
此时就会把Eden区中的存活对象都一次性转移到一块空着的Survivor区。接着Eden区就会被清空，然后再次分配新对象到Eden区里，然后，Eden区和一块Survivor区里是有对象的，其中Survivor区里放的是上一次Minor GC后存活的对象。
如果下次再次Eden区满，那么再次触发Minor GC，就会把Eden区和放着上一次Minor GC后存活对象的Survivor区内的存活对象，转移到另外一块Survivor区去。


优势:可以是使用90%的内存

**什么情况下对象进入老年代?**
1. 躲过15次Minor GC 之后会进入老年代,可以通过 -XX:MaxTenuringThresold 来设置 默认15岁

2. 动态对象年龄判断,当前存放对象的survivor区,如果一批最小年龄的对象加起来的内存占了survivor的一半,那么 survivor 剩余对象直接进入老年代. 详细规则: 年龄1+年龄2+年龄3+...+年龄n 多个对象的总和超过了survivor区的一半,那么年龄大于n的对象直接进入老年代.

3. 大对象直接进入老年代, 参数 -XX:PretenurSizeThresold

4. Minor Gc 之后存活对象大于survivor, 直接放入老年代

5. 老年代空间分配担保策略:

   ![](\images\空间担保策略.png)



详细说明

> jvm根据对象的生命周期和使用情况，分为了新生代与老年代。永久代主要存放类信息，永久代回收条件比较苛刻，该类的所有实例都已经被回收，加载这个类的类加载器已经被回收，该类的字节码对象没有任何引用。 创建一个对象时，首先会去新生代的eden区申请创建对象空间，如果eden区大小足够，则直接创建对象。若eden区不够，则会触发MinorGC，根据rootgc对象可达性分析算法，标记所有被rootgc引用的存活对象，jvm会将存活对象复制到 S区，其余的对象全部清理掉，采用的是复制算法。(在复制的过程中，如果S区大小不够，则本次存活的对象都会进入老年代，若老年代大小不够，则直接fullgc；根据动态年龄规则，若存活对象＞S区的50%，在下一次ygc时会直接进入老年代。或者ygc存活对象大于最大存活年龄15，也会进入老年代)，在触发ygc时，根据老年代的空间担保策略，会判断老年代的剩余空间是否＞新生代的内存大小或老年代剩余空间大小小于ygc平均进入老年代内存大小会直接触发fullgc，保证老年代有足够的空间存放ygc存活对象。当老年代内存对象空间超过设置的垃圾回收阈值，默认92%.会触发fullgc。





#### 垃圾回收器

> 垃圾回收器的发展过程中出现了许多不同的垃圾回收器:Serial,Serial Old,ParNew,CMS,G1等,下面针对不同的垃圾回收器,做简单介绍.

###### Serial
针对新生代内存的垃圾回收器,单线程,算法,标记复制。每次垃圾回收时,"Stop The World".使用于客户端的程序

---
###### Serial Old

针对老年代的垃圾回收器,与Serial类似,也是单线程,采用标记-压缩-清理算法。同样执行时，“Stop the world”。
---
###### ParNew

ParNew就是多线程版本的Serial，针对新生代内存,这里主要弄清多线程版本和单线程版本的优缺点。

Serial适用于Client端，垃圾回收工作对于用户的影响不大；适合单核CPU的机器，因为如果单核CPU采用多线程会因为程序的的上下文切换带来的不必要的资源开销。

ParNew适用于Server端，Server 对于程序暂停的的时间要求较高，需要对用户有较短的响应时间；适合多核CPU,默认的线程数=CPU数.设置参数 -XX:+UseParNewGC

---
###### CMS

Concurrent Mark Sweep (并发标记清除)
 
老年代垃圾回收

垃圾回收步骤:

1. 初始标记,服务暂停,通过GC Roots对象,标记直接引用对象即可,该步骤时间短,速度很快.
2. 并发标记,并行处理,不暂停服务.针对步骤1的标记,对GC.= roots,标记所有可达对象.相对耗时,同时,并发执行的过程中,也会不断产生新的对象,此时需要标记该对象.
3. 重新标记,服务暂停,针对步骤2产生的新的对象,做可达性分析.
4. 并发清除,并发清除标记的可清除对象.

优点

一种以获取最短停顿时间为目标的垃圾回收器,适合注重用户体验的线上服务

缺点:

**CPU资源**

两个并发阶段,会占用CPU资源,导致服务运行缓慢,占用的CPU数=(CPU数+3)/4，所以会至少保证占用一颗CPU

**浮动垃圾**

浮动垃圾,在并发清除的阶段,同样会产生新的老年代对象,这些新产生的老年代对象就是浮动垃.
所以在GC的过程中,通过Minor GC产生的晋升至老年代的对象可能因为老年代内存不足导致 Concurrent Model Failuer问题,如果导致这个问题,CMS会直接变更 Serial Old,单线程处理,服务暂停.

-XX:CMSInitiatingOccupancyFaction 来设置老年代占用多少比例时触发CMS

**内存碎片**

标记-清除 算法会导致内存碎片,老年代中的内存不连续.所以需要整理

-XX:UseCMSCompactAtFullCollection ,在Full GC 之后 "stop the world" 整理内存,把存活的对象放到一起

-XX:CMSFullGCsBeforeCompaction 意思是执行多少次Full GC之后执行一次内存整理,默认0,系统应当控制Full GC 的频次,不至于导致频繁的Full GC,所以默认0,每次都整理,是可以的.



---

###### G1

G1（Garbadge First Collector）作为一款JVM最新的垃圾收集器，可以解决CMS中Concurrent Mode Failed问题，尽量缩短处理超大堆的停顿，在G1进行垃圾回收的时候完成内存压缩，降低内存碎片的生成。G1在堆内存比较大的时候表现出比较高吞吐量和短暂的停顿时间，而且已成为Java 9的默认收集器。未来替代CMS只是时间的问题。

**Region**

G1的内存结构与传统的内存空间划分不同,它将内存划分成多个相同大小的region(最多2048个,每个默认大小512k),region在逻辑上连续,物理内存地址不连续.

同时每个region 又会被标记为 E(Eden年轻代),S(Survivor),Old(老年代),H(Humongous,大对象).所以G1中的新生代和老年代的划分是逻辑划分.新生代和老年代按照一定的比例(默认60:40),分配一定数量的region,这些region在逻辑上连续.对象大于等于region一半的时候,就会被认为是大对象,一个大对象可以由多个region存放,大对象通常被看做老年代回收.

**对象什么时候进入老年代?**
- 在新生代躲过多次回收,年龄达到参数设置,进入老年代
- 动态年龄判断规则,如果存活对象超过survivor内存的50% ,超过一定年龄的进入老年代

**G1的GC模式**

Young GC

当E区不能再分配新的对象时就会触发。E区的对象会移动到S区，当S区空间不够的时候，E区的对象会直接晋升到O区，同时S区的数据移动到新的S区，如果S区的部分对象到达一定年龄，会晋升到O区。

Mix GC

翻译过来叫混合回收。之所以叫混合是因为回收所有的年轻代的Region+部分老年代的Region。

1、为什么是老年代的部分Region？

2、什么时候触发Mixed GC?

这两个问题其实可以一并回答。回收部分老年代是参数-XX:MaxGCPauseMillis，用来指定一个G1收集过程目标停顿时间，默认值200ms，当然这只是一个期望值。G1的强大之处在于他有一个停顿预测模型（Pause Prediction Model），他会有选择的挑选部分Region，去尽量满足停顿时间，关于G1的这个模型是如何建立的，这里不做深究。
Mixed GC的触发也是由一些参数控制。比如XX:InitiatingHeapOccupancyPercent表示老年代占整个堆大小的百分比，默认值是45%，达到该阈值就会触发一次Mixed GC。

**Mixed GC主要可以分为两个阶段：**

1、全局并发标记（global concurrent marking）
全局并发标记又可以进一步细分成下面几个步骤：

- 初始标记（initial mark，STW）。它标记了从GC Root开始直接可达的对象。初始标记阶段借用young GC的暂停，因而没有额外的、单独的暂停阶段。
- 并发标记（Concurrent Marking）。这个阶段从GC Root开始对heap中的对象标记，标记线程与应用程序线程并行执行，并且收集各个Region的存活对象信息。过程中还会扫描上文中提到的SATB write barrier所记录下的引用。
- 最终标记（Remark，STW）。标记那些在并发标记阶段发生变化的对象，将被回收。
- 清除垃圾（Cleanup，部分STW）。这个阶段如果发现完全没有活对象的region就会将其整体回收到可分配region列表中。 清除空Region。

2、拷贝存活对象（Evacuation）
Evacuation阶段是全暂停的。它负责把一部分region里的活对象拷贝到空region里去（并行拷贝），然后回收原本的region的空间。Evacuation阶段可以自由选择任意多个region来独立收集构成收集集合（collection set，简称CSet），CSet集合中Region的选定依赖于上文中提到的停顿预测模型，该阶段并不evacuate所有有活对象的region，只选择收益高的少量region来evacuate，这种暂停的开销就可以（在一定范围内）可控。

Full GC

G1的垃圾回收过程是和应用程序并发执行的，当Mixed GC的速度赶不上应用程序申请内存的速度的时候，Mixed G1就会降级到Full GC，使用的是Serial GC。Full GC会导致长时间的STW，应该要尽量避免。
导致G1 Full GC的原因可能有两个：

- Evacuation的时候没有足够的to-space来存放晋升的对象；
- 并发处理过程完成之前空间耗尽

**优点**

ParNew +CMS的模式,在面对大内存的应用(Kafka,Elasticsearch)时,如果分配个30-40个G 的内存,那么该模式的回收垃圾,可能会停顿几秒钟.但是 G1可以预设停顿时间,部分回收,回收效率高,停顿的时间是毫秒级别的.








 



