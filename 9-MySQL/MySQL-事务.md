## 事务

### 事务的隔离级别（ISOLATION）

#### 1.Read Uncommit 读未提交
> 当前事务可以读到其他事务的未提交数据.
产生脏读的问题

#### 2.Read commited 读已提交
> 当前事务不可以读到其它事务的未提交的数据,但是可以在其他事务提交之后,读到最新的数据.产生不可重复读的问题.前后两次读的数据不一致,没有一致性(consistency)

解决脏读问题:

该级别下,通过record lock 对where...条件对应下的records 加排他锁,解决脏读.但是该级别下,不存在gap锁以及临键锁(next-key lock).

MVCC 在该级别下生效. [MVCC下的readview](https://www.cnblogs.com/jmliao/p/13204946.html)(Readview即快照) 在每次查询的时候重新生成,所以,可以读已提交.

#### 3.Repeatabel read 可重复读
> 可重复读又称为一致性读(consistency read),即在一个事务的执行过程中,多次查询的结果一致.

解决不可重复读的问题:

MVCC在该级别下生效.MVCC下的Readview在第一次查询时生成,以后的每次查询都依赖于该readview.

根据查询规则可以得出结论,可重复读只会读取在当前事务开前已经提交的数据.

幻读
可重复读的级别下产生幻读问题,但是Innodb引擎下解决了这个问题,依赖于next-key lock.

#### 4.serializable-串行化

问题引入：
```
业务逻辑：添加产品的过程中先查询后添加，声明的事务隔离级别为[serializable],由此引发问题：`Lock wait timeout exceeded; try restarting transaction`
```
业务操作量较少的情况下，对于该表的操作并发量不是很大，事务在获取事务锁时等待时间不需要太长，不会因为等待锁超时，导致异常。但是请求量稍微增大就会导致，事务等待锁超时。

什么是串行化？
```
SERIALIZABLE是事务的最高隔离级别，强制所有事务串行执行，避免幻读问题。简单来说，SERIALIZABEL会在读取的每一行数据上都加上锁，所以可能导致大量的超时和锁争用的情况。只有在非常需要保证数据的一致性，而没有并发的情况下，考虑使用该级别。---《高性能mysql第三版》
```
补充个人理解：
```
1. 数据库中锁分为共享锁（读锁 S ）和排它锁（写锁 X）
2. 事务T在对数据D加上S锁时，其它事务对数据D只能加S锁，不能加X锁。
3. 获取共享锁的事务，只能对数据读取，不能修改数据。
4. 对数据加锁的范围，遵循gap锁、Record Lock行锁和next-key lock



