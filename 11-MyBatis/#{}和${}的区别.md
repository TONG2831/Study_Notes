# #{} 和 ${}的区别，如何在实际应用中使用

> 在平常写mybatis的动态SQL语句时，大多使用的是`#{}` 。至于`${}` ，没用过，也不知道是什么。实际大多数情景下，我们使用的也都是`#{}`，很少有场景会用到`${}`。

### 1.两者的区别

- #{}：使用的是预编译，对应JBDC中的PreparedStatement
- ${}：mybatis不会修改或者转义字符换，直接输出变量值

### 2.实际应用

**举例：**

```mysql
select * from mytab order by #{sortType}
```

在这条SQL语句中，

我的意图是：排序的字段不固定，所以需要动态参数，因此下意识使用了`#｛｝。`

结果：SQL语句正确执行，但是排序功能异常。

**打印Mybatis的SQL日志：**

```mysql
select * from mytab order by ?
order_id
```

**实际执行的SQL语句:**

```mysql
select * from mytab order by 'order_id'
```

**结论**：使用#｛｝时，具体的SQL语句的参数会加上单引号，这也是导致排序失效的原因。



**那么如果使用`${}`时什么效果？**

```mysql
select * from mytab order by ${sortType}
```

**打印Mybatis的SQL日志：**

```mysql
select * from mytab order by order_id

```

**结论：**可以看出，${}中的参数是以实际值来拼接的SQL语句，而不是参数形式。

### 3.分析

**为什么大多数的时候，我们使用的是`#{}`?**

> 这里就要提到SQL注入的问题，`#{}`是以参数的形式，实际的SQL语句为参数值加**单引号** ，从而避免了SQL注入的问题。
>
> 而`${}`直接输出参数值，mybatis不做转义，可能引发SQL注入问题。

### 4.应该如何使用？

> 正常情况下，我们在写MyBatis的动态SQL语句时，大都是使用在条件查询参数，如`where order_id = #{id}`,所以不会有什么问题。但是在我们在遇到上面的例子时，我们就不能再使用`#｛｝`，可以选择使用`${}`,但是由此引发的SQL注入问题如何解决？

**如何解决在使用${}时引发的SQL注入？**

> 答案很简答，入参时做参数校验，类似`order by` 后面的字段虽然是动态的，但也是有范围的，都是表中的字段，所以可以使用枚举类做检查。

### 5.我的收获！

> 理论+实践 = 会用